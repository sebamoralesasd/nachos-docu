<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>NachOS: Thread Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">NachOS
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="classThread-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">Thread Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="thread_8hh_source.html">thread.hh</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a6a4f1862df9b8ea02719fcd643bca0c1"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classThread.html#a6a4f1862df9b8ea02719fcd643bca0c1">Thread</a> (const char *debugName, bool <a class="el" href="classThread.html#a744426869ce441c521f83784ee54924b">joinable</a>=true, int <a class="el" href="classThread.html#a85e6d6cd402deebcc79777e46351bafe">priority</a>=<a class="el" href="thread_8hh.html#aba00721c507326ce9ba597c6e7400e3c">MAX_PRIORITY</a>)</td></tr>
<tr class="memdesc:a6a4f1862df9b8ea02719fcd643bca0c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize a <code><a class="el" href="classThread.html">Thread</a></code>.  <a href="classThread.html#a6a4f1862df9b8ea02719fcd643bca0c1">More...</a><br /></td></tr>
<tr class="separator:a6a4f1862df9b8ea02719fcd643bca0c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37d9edd3a1a776cbc27dedff949c9726"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classThread.html#a37d9edd3a1a776cbc27dedff949c9726">~Thread</a> ()</td></tr>
<tr class="separator:a37d9edd3a1a776cbc27dedff949c9726"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91faf5d41cbf54162b433586aceecec7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classThread.html#a91faf5d41cbf54162b433586aceecec7">Fork</a> (<a class="el" href="utility_8hh.html#ab47fc30e09b543c1f1a5761c615f9afd">VoidFunctionPtr</a> func, void *arg)</td></tr>
<tr class="memdesc:a91faf5d41cbf54162b433586aceecec7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Basic thread operations.  <a href="classThread.html#a91faf5d41cbf54162b433586aceecec7">More...</a><br /></td></tr>
<tr class="separator:a91faf5d41cbf54162b433586aceecec7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbc2bfb172d2eff4b46882aade9eeb8a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classThread.html#adbc2bfb172d2eff4b46882aade9eeb8a">Yield</a> ()</td></tr>
<tr class="memdesc:adbc2bfb172d2eff4b46882aade9eeb8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Relinquish the CPU if any other thread is runnable.  <a href="classThread.html#adbc2bfb172d2eff4b46882aade9eeb8a">More...</a><br /></td></tr>
<tr class="separator:adbc2bfb172d2eff4b46882aade9eeb8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a187a4c1e62087511b69068220840244a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classThread.html#a187a4c1e62087511b69068220840244a">Sleep</a> ()</td></tr>
<tr class="memdesc:a187a4c1e62087511b69068220840244a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Put the thread to sleep and relinquish the processor.  <a href="classThread.html#a187a4c1e62087511b69068220840244a">More...</a><br /></td></tr>
<tr class="separator:a187a4c1e62087511b69068220840244a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae753f58f6fd1745f6f0f5baba784f4d1"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classThread.html#ae753f58f6fd1745f6f0f5baba784f4d1">Join</a> ()</td></tr>
<tr class="separator:ae753f58f6fd1745f6f0f5baba784f4d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e43c788c40e9783311c970bcea7239b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classThread.html#a1e43c788c40e9783311c970bcea7239b">Finish</a> ()</td></tr>
<tr class="memdesc:a1e43c788c40e9783311c970bcea7239b"><td class="mdescLeft">&#160;</td><td class="mdescRight">The thread is done executing.  <a href="classThread.html#a1e43c788c40e9783311c970bcea7239b">More...</a><br /></td></tr>
<tr class="separator:a1e43c788c40e9783311c970bcea7239b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a087dbaaff0eb6585ba206ce5b6d0c72e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classThread.html#a087dbaaff0eb6585ba206ce5b6d0c72e">CheckOverflow</a> () const</td></tr>
<tr class="memdesc:a087dbaaff0eb6585ba206ce5b6d0c72e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if thread has overflowed its stack.  <a href="classThread.html#a087dbaaff0eb6585ba206ce5b6d0c72e">More...</a><br /></td></tr>
<tr class="separator:a087dbaaff0eb6585ba206ce5b6d0c72e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38d99d96fa757bcf721427013cc1d0fa"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classThread.html#a38d99d96fa757bcf721427013cc1d0fa">SetStatus</a> (<a class="el" href="thread_8hh.html#ae2739961013a00cede621d4d72f2173c">ThreadStatus</a> st)</td></tr>
<tr class="separator:a38d99d96fa757bcf721427013cc1d0fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad203911be97386be2a33af241850c17"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classThread.html#aad203911be97386be2a33af241850c17">GetName</a> () const</td></tr>
<tr class="separator:aad203911be97386be2a33af241850c17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9f3f6232bdf0667802ad213e920506a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classThread.html#af9f3f6232bdf0667802ad213e920506a">Print</a> () const</td></tr>
<tr class="separator:af9f3f6232bdf0667802ad213e920506a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abba2f0c466c70fc44935ed2ef3e09f82"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classThread.html#abba2f0c466c70fc44935ed2ef3e09f82">GetRealPriority</a> ()</td></tr>
<tr class="separator:abba2f0c466c70fc44935ed2ef3e09f82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab589d5342bfae4d47420fce8c02948f7"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classThread.html#ab589d5342bfae4d47420fce8c02948f7">GetPriority</a> ()</td></tr>
<tr class="separator:ab589d5342bfae4d47420fce8c02948f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a728f17b7ed1db5afb270482b7423e5fe"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classThread.html#a728f17b7ed1db5afb270482b7423e5fe">SetPriority</a> (int <a class="el" href="classThread.html#a85e6d6cd402deebcc79777e46351bafe">priority</a>)</td></tr>
<tr class="separator:a728f17b7ed1db5afb270482b7423e5fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a705169f774fd9744d0a88b78e5397599"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classThread.html#a705169f774fd9744d0a88b78e5397599">ResetPriority</a> ()</td></tr>
<tr class="separator:a705169f774fd9744d0a88b78e5397599"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:a909904aad6d4197d9d25af6f74b845fc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classThread.html#a909904aad6d4197d9d25af6f74b845fc">StackAllocate</a> (<a class="el" href="utility_8hh.html#ab47fc30e09b543c1f1a5761c615f9afd">VoidFunctionPtr</a> func, void *arg)</td></tr>
<tr class="memdesc:a909904aad6d4197d9d25af6f74b845fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate a stack for thread. Used internally by <code>Fork</code>.  <a href="classThread.html#a909904aad6d4197d9d25af6f74b845fc">More...</a><br /></td></tr>
<tr class="separator:a909904aad6d4197d9d25af6f74b845fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:a2ac770fe6a796ca4f7fe03132961f753"><td class="memItemLeft" align="right" valign="top">uintptr_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classThread.html#a2ac770fe6a796ca4f7fe03132961f753">stackTop</a></td></tr>
<tr class="memdesc:a2ac770fe6a796ca4f7fe03132961f753"><td class="mdescLeft">&#160;</td><td class="mdescRight">The current stack pointer.  <a href="classThread.html#a2ac770fe6a796ca4f7fe03132961f753">More...</a><br /></td></tr>
<tr class="separator:a2ac770fe6a796ca4f7fe03132961f753"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae186e09a24111f5af27bbe1b8db765a5"><td class="memItemLeft" align="right" valign="top">uintptr_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classThread.html#ae186e09a24111f5af27bbe1b8db765a5">machineState</a> [<a class="el" href="thread_8hh.html#ae846b80489cd7b16bc2858333ab298d9">MACHINE_STATE_SIZE</a>]</td></tr>
<tr class="memdesc:ae186e09a24111f5af27bbe1b8db765a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">All registers except for <code>stackTop</code>.  <a href="classThread.html#ae186e09a24111f5af27bbe1b8db765a5">More...</a><br /></td></tr>
<tr class="separator:ae186e09a24111f5af27bbe1b8db765a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a283a91c94c0922af9bf7aef5b9cca690"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classChannel.html">Channel</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classThread.html#a283a91c94c0922af9bf7aef5b9cca690">channel</a></td></tr>
<tr class="separator:a283a91c94c0922af9bf7aef5b9cca690"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85e6d6cd402deebcc79777e46351bafe"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classThread.html#a85e6d6cd402deebcc79777e46351bafe">priority</a></td></tr>
<tr class="separator:a85e6d6cd402deebcc79777e46351bafe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19d2e4300c2914d501b59611953b2af6"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classThread.html#a19d2e4300c2914d501b59611953b2af6">realPriority</a></td></tr>
<tr class="separator:a19d2e4300c2914d501b59611953b2af6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5cd55fb5c3042f188757bfed87e42749"><td class="memItemLeft" align="right" valign="top">uintptr_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classThread.html#a5cd55fb5c3042f188757bfed87e42749">stack</a></td></tr>
<tr class="separator:a5cd55fb5c3042f188757bfed87e42749"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3855378e2bbc5f325c759c87d4b6b068"><td class="memItemLeft" align="right" valign="top"><a class="el" href="thread_8hh.html#ae2739961013a00cede621d4d72f2173c">ThreadStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classThread.html#a3855378e2bbc5f325c759c87d4b6b068">status</a></td></tr>
<tr class="memdesc:a3855378e2bbc5f325c759c87d4b6b068"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ready, running or blocked.  <a href="classThread.html#a3855378e2bbc5f325c759c87d4b6b068">More...</a><br /></td></tr>
<tr class="separator:a3855378e2bbc5f325c759c87d4b6b068"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf8367c62ce6a746d82304600cbd2f9c"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classThread.html#adf8367c62ce6a746d82304600cbd2f9c">name</a></td></tr>
<tr class="separator:adf8367c62ce6a746d82304600cbd2f9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a744426869ce441c521f83784ee54924b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classThread.html#a744426869ce441c521f83784ee54924b">joinable</a></td></tr>
<tr class="separator:a744426869ce441c521f83784ee54924b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>The following class defines a “thread control block” &ndash; which represents a single thread of execution.</p>
<p>Every thread has:</p><ul>
<li>an execution stack for activation records (<code>stackTop</code> and <code>stack</code>);</li>
<li>space to save CPU registers while not running (<code>machineState</code>);</li>
<li><p class="startli">a <code>status</code> (running/ready/blocked).</p>
<p class="startli">Some threads also belong to a user address space; threads that only run in the kernel have a null address space. </p>
</li>
</ul>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a6a4f1862df9b8ea02719fcd643bca0c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a4f1862df9b8ea02719fcd643bca0c1">&#9670;&nbsp;</a></span>Thread()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Thread::Thread </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>threadName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>joinable_</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>priority_</em> = <code><a class="el" href="thread_8hh.html#aba00721c507326ce9ba597c6e7400e3c">MAX_PRIORITY</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize a <code><a class="el" href="classThread.html">Thread</a></code>. </p>
<p>Initialize a thread control block, so that we can then call <code><a class="el" href="classThread.html#a91faf5d41cbf54162b433586aceecec7" title="Basic thread operations.">Thread::Fork</a></code>.</p>
<ul>
<li><code>threadName</code> is an arbitrary string, useful for debugging. </li>
</ul>

</div>
</div>
<a id="a37d9edd3a1a776cbc27dedff949c9726"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a37d9edd3a1a776cbc27dedff949c9726">&#9670;&nbsp;</a></span>~Thread()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Thread::~Thread </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Deallocate a <a class="el" href="classThread.html">Thread</a>.</p>
<p>NOTE: thread being deleted must not be running when <code>delete</code> is called.</p>
<p>De-allocate a thread.</p>
<p>NOTE: the current thread <em>cannot</em> delete itself directly, since it is still running on the stack that we need to delete.</p>
<p>NOTE: if this is the main thread, we cannot delete the stack because we did not allocate it &ndash; we got it automatically as part of starting up Nachos. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a087dbaaff0eb6585ba206ce5b6d0c72e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a087dbaaff0eb6585ba206ce5b6d0c72e">&#9670;&nbsp;</a></span>CheckOverflow()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Thread::CheckOverflow </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if thread has overflowed its stack. </p>
<p>Check a thread's stack to see if it has overrun the space that has been allocated for it. If we had a smarter compiler, we would not need to worry about this, but we do not.</p>
<p>NOTE: Nachos will not catch all stack overflow conditions. In other words, your program may still crash because of an overflow.</p>
<p>If you get bizarre results (such as seg faults where there is no code) then you <em>may</em> need to increase the stack size. You can avoid stack overflows by not putting large data structures on the stack. Do not do this: void foo() { int bigArray[10000]; ... } </p>

</div>
</div>
<a id="a1e43c788c40e9783311c970bcea7239b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e43c788c40e9783311c970bcea7239b">&#9670;&nbsp;</a></span>Finish()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Thread::Finish </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The thread is done executing. </p>
<p>Called by <code>ThreadRoot</code> when a thread is done executing the forked procedure.</p>
<p>NOTE: we do not immediately de-allocate the thread data structure or the execution stack, because we are still running in the thread and we are still on the stack! Instead, we set <code>threadToBeDestroyed</code>, so that <code><a class="el" href="classScheduler.html#a87205b0773d3dd84752ec779c890f5e1" title="Cause nextThread to start running.">Scheduler::Run</a></code> will call the destructor, once we are running in the context of a different thread.</p>
<p>NOTE: we disable interrupts, so that we do not get a time slice between setting <code>threadToBeDestroyed</code>, and going to sleep. </p>

</div>
</div>
<a id="a91faf5d41cbf54162b433586aceecec7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91faf5d41cbf54162b433586aceecec7">&#9670;&nbsp;</a></span>Fork()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Thread::Fork </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="utility_8hh.html#ab47fc30e09b543c1f1a5761c615f9afd">VoidFunctionPtr</a>&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Basic thread operations. </p>
<p>Make thread run <code>(*func)(arg)</code>.</p>
<p>Invoke <code>(*func)(arg)</code>, allowing caller and callee to execute concurrently.</p>
<p>NOTE: although our definition allows only a single integer argument to be passed to the procedure, it is possible to pass multiple arguments by by making them fields of a structure, and passing a pointer to the structure as "arg".</p>
<p>Implemented as the following steps:</p><ol type="1">
<li>Allocate a stack.</li>
<li>Initialize the stack so that a call to SWITCH will cause it to run the procedure.</li>
<li>Put the thread on the ready queue.</li>
</ol>
<ul>
<li><code>func</code> is the procedure to run concurrently.</li>
<li><code>arg</code> is a single argument to be passed to the procedure. </li>
</ul>

</div>
</div>
<a id="aad203911be97386be2a33af241850c17"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad203911be97386be2a33af241850c17">&#9670;&nbsp;</a></span>GetName()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char * Thread::GetName </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab589d5342bfae4d47420fce8c02948f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab589d5342bfae4d47420fce8c02948f7">&#9670;&nbsp;</a></span>GetPriority()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Thread::GetPriority </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="abba2f0c466c70fc44935ed2ef3e09f82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abba2f0c466c70fc44935ed2ef3e09f82">&#9670;&nbsp;</a></span>GetRealPriority()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Thread::GetRealPriority </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae753f58f6fd1745f6f0f5baba784f4d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae753f58f6fd1745f6f0f5baba784f4d1">&#9670;&nbsp;</a></span>Join()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Thread::Join </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af9f3f6232bdf0667802ad213e920506a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9f3f6232bdf0667802ad213e920506a">&#9670;&nbsp;</a></span>Print()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Thread::Print </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a705169f774fd9744d0a88b78e5397599"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a705169f774fd9744d0a88b78e5397599">&#9670;&nbsp;</a></span>ResetPriority()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Thread::ResetPriority </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a728f17b7ed1db5afb270482b7423e5fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a728f17b7ed1db5afb270482b7423e5fe">&#9670;&nbsp;</a></span>SetPriority()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Thread::SetPriority </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>priority</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a38d99d96fa757bcf721427013cc1d0fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38d99d96fa757bcf721427013cc1d0fa">&#9670;&nbsp;</a></span>SetStatus()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Thread::SetStatus </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="thread_8hh.html#ae2739961013a00cede621d4d72f2173c">ThreadStatus</a>&#160;</td>
          <td class="paramname"><em>st</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a187a4c1e62087511b69068220840244a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a187a4c1e62087511b69068220840244a">&#9670;&nbsp;</a></span>Sleep()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Thread::Sleep </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Put the thread to sleep and relinquish the processor. </p>
<p>Relinquish the CPU, because the current thread is blocked waiting on a synchronization variable (<code><a class="el" href="classSemaphore.html">Semaphore</a></code>, <code><a class="el" href="classLock.html">Lock</a></code>, or <code><a class="el" href="classCondition.html">Condition</a></code>). Eventually, some thread will wake this thread up, and put it back on the ready queue, so that it can be re-scheduled.</p>
<p>NOTE: if there are no threads on the ready queue, that means we have no thread to run. <code><a class="el" href="classInterrupt.html#ace54aece18806bae3614ebf9cc8c2991">Interrupt::Idle</a></code> is called to signify that we should idle the CPU until the next I/O interrupt occurs (the only thing that could cause a thread to become ready to run).</p>
<p>NOTE: we assume interrupts are already disabled, because it is called from the synchronization routines which must disable interrupts for atomicity. We need interrupts off so that there cannot be a time slice between pulling the first thread off the ready list, and switching to it. </p>

</div>
</div>
<a id="a909904aad6d4197d9d25af6f74b845fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a909904aad6d4197d9d25af6f74b845fc">&#9670;&nbsp;</a></span>StackAllocate()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Thread::StackAllocate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="utility_8hh.html#ab47fc30e09b543c1f1a5761c615f9afd">VoidFunctionPtr</a>&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allocate a stack for thread. Used internally by <code>Fork</code>. </p>
<p>Allocate and initialize an execution stack.</p>
<p>The stack is initialized with an initial stack frame for <code>ThreadRoot</code>, which:</p><ol type="1">
<li>enables interrupts;</li>
<li>calls <code>(*func)(arg)</code>;</li>
<li>calls <code><a class="el" href="classThread.html#a1e43c788c40e9783311c970bcea7239b" title="The thread is done executing.">Thread::Finish</a></code>.</li>
</ol>
<ul>
<li><code>func</code> is the procedure to be forked.</li>
<li><code>arg</code> is the parameter to be passed to the procedure. </li>
</ul>

</div>
</div>
<a id="adbc2bfb172d2eff4b46882aade9eeb8a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adbc2bfb172d2eff4b46882aade9eeb8a">&#9670;&nbsp;</a></span>Yield()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Thread::Yield </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Relinquish the CPU if any other thread is runnable. </p>
<p>Relinquish the CPU if any other thread is ready to run.</p>
<p>If so, put the thread on the end of the ready list, so that it will eventually be re-scheduled.</p>
<p>NOTE: returns immediately if no other thread on the ready queue. Otherwise returns when the thread eventually works its way to the front of the ready list and gets re-scheduled.</p>
<p>NOTE: we disable interrupts, so that looking at the thread on the front of the ready list, and switching to it, can be done atomically. On return, we re-set the interrupt level to its original state, in case we are called with interrupts disabled.</p>
<p>Similar to <code><a class="el" href="classThread.html#a187a4c1e62087511b69068220840244a" title="Put the thread to sleep and relinquish the processor.">Thread::Sleep</a></code>, but a little different. </p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a283a91c94c0922af9bf7aef5b9cca690"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a283a91c94c0922af9bf7aef5b9cca690">&#9670;&nbsp;</a></span>channel</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classChannel.html">Channel</a>* Thread::channel</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a744426869ce441c521f83784ee54924b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a744426869ce441c521f83784ee54924b">&#9670;&nbsp;</a></span>joinable</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Thread::joinable</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ae186e09a24111f5af27bbe1b8db765a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae186e09a24111f5af27bbe1b8db765a5">&#9670;&nbsp;</a></span>machineState</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uintptr_t Thread::machineState[<a class="el" href="thread_8hh.html#ae846b80489cd7b16bc2858333ab298d9">MACHINE_STATE_SIZE</a>]</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>All registers except for <code>stackTop</code>. </p>

</div>
</div>
<a id="adf8367c62ce6a746d82304600cbd2f9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf8367c62ce6a746d82304600cbd2f9c">&#9670;&nbsp;</a></span>name</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const char* Thread::name</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a85e6d6cd402deebcc79777e46351bafe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85e6d6cd402deebcc79777e46351bafe">&#9670;&nbsp;</a></span>priority</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int Thread::priority</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a19d2e4300c2914d501b59611953b2af6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19d2e4300c2914d501b59611953b2af6">&#9670;&nbsp;</a></span>realPriority</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int Thread::realPriority</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a5cd55fb5c3042f188757bfed87e42749"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5cd55fb5c3042f188757bfed87e42749">&#9670;&nbsp;</a></span>stack</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uintptr_t* Thread::stack</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Bottom of the stack.</p>
<p>Null if this is the main thread. (If null, do not deallocate stack.) </p>

</div>
</div>
<a id="a2ac770fe6a796ca4f7fe03132961f753"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ac770fe6a796ca4f7fe03132961f753">&#9670;&nbsp;</a></span>stackTop</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uintptr_t* Thread::stackTop</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The current stack pointer. </p>

</div>
</div>
<a id="a3855378e2bbc5f325c759c87d4b6b068"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3855378e2bbc5f325c759c87d4b6b068">&#9670;&nbsp;</a></span>status</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="thread_8hh.html#ae2739961013a00cede621d4d72f2173c">ThreadStatus</a> Thread::status</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Ready, running or blocked. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>code/threads/<a class="el" href="thread_8hh_source.html">thread.hh</a></li>
<li>code/threads/<a class="el" href="thread_8cc.html">thread.cc</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
